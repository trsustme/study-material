# Процессы в Linux

## Программа, процесс, потоки

### Программа

Программа - это исполняемый файл, который хранит всю нужную информацию для создания процесса

ELF(Executable and Linking Format) - современный формат бинарных исполняемых файлов. Может быть скомпонован(слинкован):
- статические - в ELF файл помещается бинарный код вызываемых функций, содержащихся в библиотеках
    - больше по размеру, чем динмаически скомпонованные программы, но могут быть запущены на другой системе с той же
    аппаратной платформой
- динамически - в ELF файле содержится только информация о функциях из библиотек, код библиотечных функций
подсоединяется во время создания процесса

### Процесс

Процесс - экземпляр исполняющейся программы, это сущность создаваемая ядром(fork()).

Адресное пространство процесса состоит из:
- пользовательского пространства
    - код программы
    - код используемых библиотечных фукнций
    - инициализированные данные из программы
    - неинициализированные статические данные, определенные в программе
    - динамически размещаемые данные
    - стек
- таблицы процессов - структуры, хранящиеся в пространстве ядра
    - идентификаторы
        - PID - самого процесса
        - PPID - родительского процесса
        - RUID - реального пользователя
        - RGID - реальной группы - наследуются от владельца родительского процесса
        - использующиеся для проверок доступа процесса к файлам
            - EUID - эффективного пользователя
            - EGID - эффективной группы
    - таблица дескрипторов открытых файлов
    - имя рабочего(текущего) каталога
    - другие сведения
        - информация об обработчиках сигнала
        - об ограниения использования ресурсов
        - т.д.

Процессы организованы в иерархическую структуру(похожую на ФС).
Верхний процесс - systemd (PID=1)

Процессы изолированы друг от друга - каждому процессу выделяется свое виртуальное пространство.

IPC(InterProcess Communication) - механизм ядра, с помощью которого процессы взаимодействуют между собой.

### Потоки

Один процесс может содержать несколько потоков выполнения(threads), где первый поток является главным.

Потоки внутри одного процесса:
- планируются и выполняются независимо
- разделяют данные процесса
    - инициализированные переменные
    - неинициализированные переменные
    - динамически размещаемые данные - кучу
    - атрибуты
        - PID
        - PPID
        - дескрипторы открытых файлов
        - блокировки файлов
        - действия сигналов
        - текущий каталог
        - т.д.
- взаимодействуют быстрее, чем межпроцессорное взаимодействие

Мьютекс - примитив синхронизации потоков.

Потоки должны использовать только потокобезопасные функции - thread-safe functions.

Ошибка в одном потоке может привести к ошибкам в других потоках.

В планировщике(диспетчере) потоков создается сущность при каждом создании потока.

Работа потока планируется ядром.

### Жизненный цикл процесса

1. Системный вызов `fork()` создает новый процесс от родительского.
Родительский и дочерний процессы выполняют один и тот же код, но у каждого из них своя копия сегментов данных, кучи и стека.

2. Дочерний процесс получает от родительского процесса:
- копию переменных окружения
- дубли дескрипторов открытых файлов

3. Системный вызов `execve(имя_программы, )` - заменяет код процесса, в котором выполнился системный вызов, на код
указанной программы. И сегменты данных заново инициализируются.
`execve()` - не обязательный при создании нового процесса. Он подменяет существующий процесс кодом
и данными другой программы.

4. `exit(код_завершения)` - завершает процесс, освобождая все ресурсы процесса. код_завершения извлекается родительским
процессом с помощью `wait()`

5. `wait()` - приостанавливает выполнение родительского процесса до завершения работы дочернего и получает его код
завершения.

6. Если код_завершения = 0, то дочерний процесс завершился успешно.

### Типы и состояния процессов

Типы процессов:
- пользовательские - связаны с терминальном
- службы(демоны) - не связаны с терминальном

Состояния процессов:
- R(runnable) - процесс использует процессор, либо находится в очереди за получение процессорного ресурса
- S(sleeping) - прерываемый сон, может быть разбужен сигналом - напр., завершением операции ввода/вывода
- D(uninterruptable sleep) - непрерываемый сон, не может быть разбужен сигналом, сигнал будет обработан только после
получения доступа к ресурсу
- T(stopped) - процесс приостановлен (Ctrl+Z, SIGTSTP)
- Z(zombie) - процесс завершился, но код завершения не получен

Дочерний процесс находится в состоянии Z после того как он завершит свою работу с помощью exit() и до того, как
родительский процесс обработает его код завершения.

Ресурсы дочернего процесса освобождаются при вызове exit(), но в памяти ядра в таблице процессов остается информация:
- PID
- другие идентификаторы
- статистика процесса
- т.д.

Процесс, находящийся в состоянии Z, нельзя завершить даже SIGKILL. Ядро само удалит зомби процесс после того, как
родительский процесс выполнит wait().
Чтобы уничтожить зомби процесс надо завершить родительский процесс.

Может быть создано очень много зомби процессов, если родительский процесс будет создавать дочерние процессы и не будет
успевать выполнять wait()

Если родительский процесс завершается раньше, чем дочерний, то дочерний процесс становится дочерним процесса systemd
(PID=1), и всю последующую информацию о завершении дочернего процесса будет получать процесс systemd.

При запуске службы(демона):
- служба стартует как дочерний процесс
- родительский процесс тут же завершается
- служба удочеряется systemd
- служба становится лидером сессии
    - не открывает терминальное устройство
    - отвязывается от управляющего терминала
- рабочий каталог меняется на /
- служба закрывает все открытые в родительском процессе файлы и перенаправляет стд. потоки ввода/вывода в /dev/null

## Межпроцессорное взаимодействие(IPC)

Механизмы межпроцессорного взаимодействия
- обмен каналами
    - каналы и очереди(FIFO)
    - сокеты(локальные и сетевые)
    - очереди сообщений
    - разделяемая память
- синхронизация работы процессов
    - семафоры
    - блокировки файлов
- сигналы

### Обмен данными

#### Каналы и очереди

Каналы(неименованные каналы) - используются для организации конвейеров в командной строке с помощью `|`

Канал соединяет стандартный вывод первого процесса(файловый дескриптор 1) со стандартным вводом второго
процесса(файловый дескриптор 2)

Данные в канале передаются как поток последовательных байтов, передача данных однонаправленная.

Очереди(именованные каналы) - отличаются от каналов тем, что при работе используют файлы специального типа (pipe).
- первый процесс открывает файл на запись
- второй процесс открывает файл на чтение
- первый передает данные во второй

`mkfifo имя_канала` - создать очередь.

#### Сокеты

Сокеты организуют двунаправленное взаимодействие между клиентом и сервером:
- клиент и сервер создают сокеты
- сервер привязывает(bind) свой сокет к известному клиентам имени
- клиент устанавливает соединение своего сокета с серверным сокетом
- клиент и сервер обмениваются данными

Типы сокетов:
- потоковые(stream) - ориентированы на соединение и обеспечивают надежную передачу данных
- датаграммные(datagram) - не обеспечивают надежную передачу данных

Ядро ОС поддерживает три домена взаимодействия между сокетами:
- UNIX-домен - локальные сокеты, используются файлы специального типа socket
- сетевые сокеты
    - IPv4-домен
    - IPv6-домен

#### Очереди сообщений

Очереди сообщений предназначены для организации межпроцессорного взаимодействия путем обмена упорядоченными(по
приоритету) блоками данных(сообщениями)


### Синхронизация работы процессов

Механизм разделяемой памяти организован с помощью создания областей tmpfs в файловой системе для совместного
использования процессами.
- файловая система tmpfs размещается в памяти и монитруется в /dev/shm

#### Семафоры

Семафор - объект, который может принимать неотрицательное целочисленное значение, которое увеличивается или уменьшается
процессами.

Семафоры хранятся в tmpfs смонтированной в /dev/shm

`ipcs` - вывести информацию:
- об очередях сообщений
- о разделяемой памяти
- о семафорах

## Общие библиотеки

Общие библиотеки - это библиотеки, которые могут быть связаны с любой программой во время выполнения, путем загрузки
кода в любое место памяти.

После загрузки код общей библиотеки может использоваться любым количеством программ.

Альтернативный путь настройки путей до общих библиотек - перечислить каталоги в переменной LD_LIBRARY_PATH.


`ldd имя_программа` - показать, какие требуются общие библиотеки для запуска динамически скомпонованной программы

`/etc/ld.so.conf` или conf файлы в `/etc/ld.so.conf.d` - находится настройка местонахождения общих библиотек
- в конфигурационных файлах помещаются имена каталогов, содержащих общие библиотеки

`ldconfig` - создать кэш, в котором хранится информация обо всех библиотеках (`/etc/ld.so.cache`)

`ldconfig -p` - вывести список библиотек, хранимый в кэше

## Мониторинг процессов

- `/proc/<PID>` - атрибуты процессов
    - `/proc/<PID>/status` - содержит информацию о процессе
    - `/proc/<PID>/fd` - символические ссылки для каждого открытого файла
    - `/proc/<PID>/task` - каталоги, в которых размещена информация о потоках
- `ps`
    - -e - все процессы
    - -f - наиболее популярные атрибуты процессов
    - -l - детальная информация о процессах
    - -aux - все процессы, поля, показывающие относительную загрузку процессора и использование памяти
    - -o поля - вывод указанных атрибутов процессов
    - -L - информация о потоках
    - -p PID - информация о процессе с указанным PID
    - `man ps | grep -A 400 '^STANDARD FORMAT' | vim`
- `top`
- `pstree` - вывести иерархическое дерево процессов
- `pgrep регулярное_выражение` - ps + grep
- `pidof имя_программы` - вывести PID процессов, запущенных программой

### top

В верхней части экрана показывает информацию по всей системе:
- общее время работы системы
- среднюю загрузку системы(load average) в последние минуту, пять и пятнадцать минут
- информация о количестве процессов и их состояниях
- процент использования процессорного времени
- оперативная память
- область подкачки

В нижней части экрана показывает информацию о процессах:
- PID
- эффективный пользователь
- приоритет
- значение NICE
- размер виртуальной памяти
- количество физической памяти, занятой процессом
- объем памяти, совместно используемой с другими процессами
- состояние процесса
- процент использования процессорного времени после последнего обновления информации
- процент использования физической памяти
- общее количество использованного процессорного времени
- команда

Команды для top
- h или ? - выводит экран со списком команд
- k передача сигнала процессу
- u и U - процессы пользователя(эффективного и реального)
- f - действия с полями

## Управление приоритетом процесса

У процессов реального времени приоритет статический от 1 до 99

У процессов разделения времени: статический приоритет(0) и динамический приоритет

Динамический проритет зависит от числа NICE(-20 +19)

- `nice -n число команда` - установить nice у нового процесса
- `renice -n число -p PID` - изменить nice у запущенного процесса

У процессов реального времени(real time) приоритет всегда выше, чем у процессов разделения времени(time shared)

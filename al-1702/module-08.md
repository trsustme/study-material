# Процессы в Linux

## Программа, процесс, потоки

### Программа

Программа - это исполняемый файл, который хранит всю нужную информацию для создания процесса

ELF(Executable and Linking Format) - современный формат бинарных исполняемых файлов. Может быть скомпонован(слинкован):
- статические - в ELF файл помещается бинарный код вызываемых функций, содержащихся в библиотеках
    - больше по размеру, чем динамически скомпонованные программы, но могут быть запущены на другой системе с той же
    аппаратной платформой
- динамически - в ELF файле содержится только информация о функциях из библиотек, код библиотечных функций
подсоединяется во время создания процесса

### Процесс

Процесс - экземпляр исполняющейся программы, это сущность создаваемая ядром(fork()).

Адресное пространство процесса состоит из:
- пользовательского пространства
    - код программы
    - код используемых библиотечных фукнций
    - инициализированные данные из программы
    - неинициализированные статические данные, определенные в программе
    - динамически размещаемые данные
    - стек
- таблицы процессов - структуры, хранящиеся в пространстве ядра
    - идентификаторы
        - PID - самого процесса
        - PPID - родительского процесса
        - RUID - реального пользователя
        - RGID - реальной группы - наследуются от владельца родительского процесса
        - использующиеся для проверок доступа процесса к файлам
            - EUID - эффективного пользователя
            - EGID - эффективной группы
    - таблица дескрипторов открытых файлов
    - имя рабочего(текущего) каталога
    - другие сведения
        - информация об обработчиках сигнала
        - об ограниения использования ресурсов
        - т.д.

Процессы организованы в иерархическую структуру(похожую на ФС).
Верхний процесс - systemd (PID=1)

Процессы изолированы друг от друга - каждому процессу выделяется свое виртуальное пространство.

IPC(InterProcess Communication) - механизм ядра, с помощью которого процессы взаимодействуют между собой.

### Потоки

Один процесс может содержать несколько потоков выполнения(threads), где первый поток является главным.

Потоки внутри одного процесса:
- планируются и выполняются независимо
- разделяют данные процесса
    - инициализированные переменные
    - неинициализированные переменные
    - динамически размещаемые данные - кучу
    - атрибуты
        - PID
        - PPID
        - дескрипторы открытых файлов
        - блокировки файлов
        - действия сигналов
        - текущий каталог
        - т.д.
- взаимодействуют быстрее, чем межпроцессорное взаимодействие

Мьютекс - примитив синхронизации потоков.

Потоки должны использовать только потокобезопасные функции - thread-safe functions.

Ошибка в одном потоке может привести к ошибкам в других потоках.

В планировщике(диспетчере) потоков создается сущность при каждом создании потока.

Работа потока планируется ядром.

### Жизненный цикл процесса

1. Системный вызов `fork()` создает новый процесс от родительского.
Родительский и дочерний процессы выполняют один и тот же код, но у каждого из них своя копия сегментов данных, кучи и стека.

2. Дочерний процесс получает от родительского процесса:
- копию переменных окружения
- дубли дескрипторов открытых файлов

3. Системный вызов `execve(имя_программы, )` - заменяет код процесса, в котором выполнился системный вызов, на код
указанной программы. И сегменты данных заново инициализируются.
`execve()` - не обязательный при создании нового процесса. Он подменяет существующий процесс кодом
и данными другой программы.

4. `exit(код_завершения)` - завершает процесс, освобождая все ресурсы процесса. код_завершения извлекается родительским
процессом с помощью `wait()`

5. `wait()` - приостанавливает выполнение родительского процесса до завершения работы дочернего и получает его код
завершения.

6. Если код_завершения = 0, то дочерний процесс завершился успешно.

### Типы и состояния процессов

Типы процессов:
- пользовательские - связаны с терминальном
- службы(демоны) - не связаны с терминальном

Состояния процессов:
- R(runnable) - процесс использует процессор, либо находится в очереди за получение процессорного ресурса
- S(sleeping) - прерываемый сон, может быть разбужен сигналом - напр., завершением операции ввода/вывода
- D(uninterruptable sleep) - непрерываемый сон, не может быть разбужен сигналом, сигнал будет обработан только после
получения доступа к ресурсу
- T(stopped) - процесс приостановлен (Ctrl+Z, SIGTSTP)
- Z(zombie) - процесс завершился, но код завершения не получен
    - процесс, находящийся в состоянии Z, нельзя завершить даже SIGKILL. Ядро само удалит зомби процесс после того, как
    родительский процесс выполнит wait().
    - чтобы уничтожить зомби процесс надо завершить родительский процесс.
    - дочерний процесс находится в состоянии Z после того как он завершит свою работу с помощью exit() и до того, как
    родительский процесс обработает его код завершения.

Ресурсы дочернего процесса освобождаются при вызове exit(), но в памяти ядра в таблице процессов остается информация:
- PID
- другие идентификаторы
- статистика процесса
- д.р.


Может быть создано очень много зомби процессов, если родительский процесс будет создавать дочерние процессы и не будет
успевать выполнять wait()

Если родительский процесс завершается раньше, чем дочерний, то дочерний процесс становится дочерним процесса systemd
(PID=1), и всю последующую информацию о завершении дочернего процесса будет получать процесс systemd.

При запуске службы(демона):
- служба стартует как дочерний процесс
- родительский процесс тут же завершается
- служба удочеряется systemd
- служба становится лидером сессии
    - не открывает терминальное устройство
    - отвязывается от управляющего терминала
- рабочий каталог меняется на /
- служба закрывает все открытые в родительском процессе файлы и перенаправляет стд. потоки ввода/вывода в /dev/null

## Межпроцессорное взаимодействие(IPC)

Механизмы межпроцессорного взаимодействия
- обмен каналами
    - каналы и очереди(FIFO)
    - сокеты(локальные и сетевые)
    - очереди сообщений
    - разделяемая память
- синхронизация работы процессов
    - семафоры
    - блокировки файлов
- сигналы

### Обмен данными

#### Каналы и очереди

Каналы(неименованные каналы) - используются для организации конвейеров в командной строке с помощью `|`

Канал соединяет стандартный вывод первого процесса(файловый дескриптор 1) со стандартным вводом второго
процесса(файловый дескриптор 2)

Данные в канале передаются как поток последовательных байтов, передача данных однонаправленная.

Очереди(именованные каналы) - отличаются от каналов тем, что при работе используют файлы специального типа (pipe).
- первый процесс открывает файл на запись
- второй процесс открывает файл на чтение
- первый передает данные во второй

`mkfifo имя_канала` - создать очередь.

#### Сокеты

Сокеты организуют двунаправленное взаимодействие между клиентом и сервером:
- клиент и сервер создают сокеты
- сервер привязывает(bind) свой сокет к известному клиентам имени
- клиент устанавливает соединение своего сокета с серверным сокетом
- клиент и сервер обмениваются данными

Типы сокетов:
- потоковые(stream) - ориентированы на соединение и обеспечивают надежную передачу данных
- датаграммные(datagram) - не обеспечивают надежную передачу данных

Ядро ОС поддерживает три домена взаимодействия между сокетами:
- UNIX-домен - локальные сокеты, используются файлы специального типа socket
- сетевые сокеты
    - IPv4-домен
    - IPv6-домен

#### Очереди сообщений

Очереди сообщений предназначены для организации межпроцессорного взаимодействия путем обмена упорядоченными(по
приоритету) блоками данных(сообщениями)


### Синхронизация работы процессов

Механизм разделяемой памяти организован с помощью создания областей tmpfs в файловой системе для совместного
использования процессами.
- файловая система tmpfs размещается в памяти и монитруется в /dev/shm

#### Семафоры

Семафор - объект, который может принимать неотрицательное целочисленное значение, которое увеличивается или уменьшается
процессами.

Семафоры хранятся в tmpfs смонтированной в /dev/shm

`ipcs` - вывести информацию:
- об очередях сообщений
- о разделяемой памяти
- о семафорах

## Общие библиотеки

Общие библиотеки - это библиотеки, которые могут быть связаны с любой программой во время выполнения, путем загрузки
кода в любое место памяти.

После загрузки код общей библиотеки может использоваться любым количеством программ.

Альтернативный путь настройки путей до общих библиотек - перечислить каталоги в переменной LD_LIBRARY_PATH.

`ldd имя_программа` - показать, какие требуются общие библиотеки для запуска динамически скомпонованной программы

`/etc/ld.so.conf` или conf файлы в `/etc/ld.so.conf.d` - находится настройка местонахождения общих библиотек
- в конфигурационных файлах помещаются имена каталогов, содержащих общие библиотеки

`ldconfig` - создать кэш, в котором хранится информация обо всех библиотеках (`/etc/ld.so.cache`)

`ldconfig -p` - вывести список библиотек, хранимый в кэше

## Мониторинг процессов

- `/proc/<PID>` - атрибуты процессов
    - `/proc/<PID>/status` - содержит информацию о процессе
    - `/proc/<PID>/fd` - символические ссылки для каждого открытого файла
    - `/proc/<PID>/task` - каталоги, в которых размещена информация о потоках
- `ps`
    - -e - все процессы
    - -f - наиболее популярные атрибуты процессов
    - -l - детальная информация о процессах
    - -aux - все процессы, поля, показывающие относительную загрузку процессора и использование памяти
    - -o поля - вывод указанных атрибутов процессов
    - -L - информация о потоках
    - -p PID - информация о процессе с указанным PID
    - `man ps | grep -A 400 '^STANDARD FORMAT' | vim`
- `top`
- `pstree` - вывести иерархическое дерево процессов
- `pgrep регулярное_выражение` - ps + grep
- `pidof имя_программы` - вывести PID процессов, запущенных программой
    - `echo $(pidof sleep)`

### top

В верхней части экрана показывает информацию по всей системе:
- общее время работы системы
- среднюю загрузку системы(load average) в последние минуту, пять и пятнадцать минут
- информация о количестве процессов и их состояниях
- процент использования процессорного времени
- оперативная память
- область подкачки

В нижней части экрана показывает информацию о процессах:
- PID
- эффективный пользователь
- приоритет
- значение NICE
- размер виртуальной памяти
- количество физической памяти, занятой процессом
- объем памяти, совместно используемой с другими процессами
- состояние процесса
- процент использования процессорного времени после последнего обновления информации
- процент использования физической памяти
- общее количество использованного процессорного времени
- команда

Команды для top
- h или ? - выводит экран со списком команд
- k передача сигнала процессу
- u и U - процессы пользователя(эффективного и реального)
- f - действия с полями

## Управление приоритетом процесса

Планировщик процессов поддерживает алгоритмы планирования разделения времени(SCHED_OTHER) и реального
времени(SCHED_FIFO, SCHED_RR)

`ps -o pid,cls,pri,rtprio,comm` - посмотреть pid, какой режим работы процесса, приоритет, статический приоритет

CLS - режим работы процесса:
- TS - разделение времени
- FF - реальное время(FIFO)

### Процессы реального времени

У процессов реального времени приоритет статический от 1 до 99

У процессов реального времени(real time) приоритет всегда выше, чем у процессов разделения времени(time shared).

`chrt` - создать процесс реального времени
- `sudo chrt -f 1 bash` - в режиме реального времени запускается командный интерпретатор со статическим приоритетом 1.

### Процессы разделения времени

У процессов разделения времени: статический приоритет(0) и динамический приоритет

Процессы разделения времени планируются, исходя из динамического приоритета.

#### NICE

Динамический проритет зависит от числа NICE(-20 до +19). По умолчанию NICE = 0
- чем больше NICE, тем меньше динамический приоритет процесса

Обычный пользователь может только увеличить NICE, а уменьшить только root.

- `nice -n значение_nice команда(COMMAND)` - установить nice у нового процесса
- `renice -n значение_nice -p PID_процесса` - изменить nice у запущенного процесса
    - `-u имя_учетной_записи_пользователя` - изменить у всех процессов пользователя
    - `-g имя_учетной_записи_группы` - изменить у всех процессов, содержащих указанный GID

## Сигналы

Сигнал - один из механизмов IPC, один процесс может отправить другому процессу оповещение о событии.
- процесс может сам себе посласть сигнал.

Сигнал в большинстве случаев отправляется ядром ОС асинхронно(т.е. нельзя сказать точное время доставки сигнала).
- ввод с клавиатуры пользователем Ctrl+C
- программное событие(напр., изменение размера окна терминала)
- аппаратное исключительное событие(напр., деление на ноль)

Схема работы сигнала:
1) событие генерирует сигнал
2) сигнал ожидает, когда процесс, которому предназначен сигнал, начнет выполняется
3) сигнал доставляется в процесс
4) после доставки сигнала:
    - или выполняется действие по умолчанию
        - сброс сигнала ядром и аварийное завершение процесса
        - приостановка процесса
        - возобновление процесса
        - создание дамп процесса
        - завершение процесса
    - или сигнал процессом игнорируется
    - или выполняется написанный программистом обработчик сигнала

`kill -l` - список сигналов

`kill -номер_или_имя_сигнала PID_процесса` - передача сигнала процессу, по умолчанию это SIGTERM
- SIGHUP - при передаче службе - перечитывание конфигурационного файла службы, при выходе из bash рассылается всем
порожденным процессам, завершая их
- SIGINT - аварийное завершение процесса `Ctrl+C`
- SIGQUIT - дамп и аварийное завершение процесса `Ctrl+\`
- SIGKILL - безусловное завершение процесса
- SIGTERM - завершение процесса
- SIGTSTP, SIGCONT - приостановка(`Ctrl+Z`) и возобновление процесса
- SIGUSR1, SIGUSR2 - пользовательские сигналы, могут использоваться в ПО в разных целях
- SIGWINCH - изменение размера окна терминала

SIGTERM, SIGINT, SIGQUIT, SIGKILL - рекомендуемая последовательность передачи сигналов процессу, когда требуется его
завершить

`nohup командная_строка` - защитить процесс от сигнала SIGHUP, для процесса запускаемого в командном интерпретаторе

`trap команда сигнал` - создать обработчик сигналов для командного интерпретатора bash
    - `trap "echo Сигнал заблокирован" 2 3` - перехватчик сигналов SIGINT(2) и SIGQUIT(3), который выводит это сообщение

## Управление заданиями

`jobs` - получить список заданий, запущенных в текущей командной оболочке и исполнящихся в фоновом режиме

`Ctrl+Z` - приостановка активного задания

`fg %номер_задания` - сделать задание активным

`bg %номер_задания` - сделать задание фоновым

`команда &` - запустить задание фоном

`kill -сигнал %номер_задания` - отправить сигнал заданию

---

`ps -e -o nlwp | tr -d " " | grep -v "^1$" | wc -l` - получить количество процессов, имеющих несколько потоков выполнения
